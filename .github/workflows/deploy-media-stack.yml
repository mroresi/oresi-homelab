name: Deploy Media Stack

on:
  push:
    branches: [main]
    paths:
      - "stacks/stack-media/**"
      - "chatops/intents/rollout_stack_media.yaml"
      - "chatops/intents/scale_stack_media.yaml"

  workflow_dispatch:
    inputs:
      intent:
        description: "Intent to execute"
        required: true
        default: "rollout_stack_media"
        type: choice
        options:
          - rollout_stack_media
          - scale_stack_media

jobs:
  validate:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Validate stack configuration
        run: |
          # Skip validation on manual dispatch (stacks may live outside this repo)
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "â„¹ï¸  Skipping stack validation on manual dispatch"
            exit 0
          fi

          if [ ! -f "stacks/stack-media/docker-compose.yml" ]; then
            echo "âŒ docker-compose.yml not found"
            exit 1
          fi

          # Basic YAML syntax check
          python3 -c "import yaml; yaml.safe_load(open('stacks/stack-media/docker-compose.yml'))"
          echo "âœ… Stack configuration is valid"

  deploy:
    needs: validate
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Verify required secrets
        env:
          TS_OAUTH_CLIENT_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_OAUTH_CLIENT_SECRET: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
        run: |
          if [ -z "$TS_OAUTH_CLIENT_ID" ]; then
            echo "âŒ Missing required secret: TS_OAUTH_CLIENT_ID"
            echo "Please add Tailscale OAuth credentials to GitHub Secrets"
            exit 1
          fi
          if [ -z "$TS_OAUTH_CLIENT_SECRET" ]; then
            echo "âŒ Missing required secret: TS_OAUTH_CLIENT_SECRET"
            echo "Please add Tailscale OAuth credentials to GitHub Secrets"
            exit 1
          fi
          echo "âœ… All required secrets are configured"

      - name: Detect Tailscale credentials
        id: tscreds
        env:
          TS_ID: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          TS_SECRET: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}
          TS_AUTHKEY: ${{ secrets.TAILSCALE_AUTHKEY }}
        run: |
          have_oauth=0
          if [ -n "$TS_ID" ] && [ -n "$TS_SECRET" ]; then have_oauth=1; fi
          have_authkey=0
          if [ -n "$TS_AUTHKEY" ]; then have_authkey=1; fi
          echo "have_oauth=$have_oauth" >> $GITHUB_OUTPUT
          echo "have_authkey=$have_authkey" >> $GITHUB_OUTPUT

      - name: Install Tailscale (OAuth)
        if: ${{ steps.tscreds.outputs.have_oauth == '1' }}
        uses: tailscale/github-action@v2
        with:
          oauth-client-id: ${{ secrets.TS_OAUTH_CLIENT_ID }}
          oauth-secret: ${{ secrets.TS_OAUTH_CLIENT_SECRET }}

      - name: Install Tailscale (Authkey fallback)
        if: ${{ steps.tscreds.outputs.have_oauth != '1' && steps.tscreds.outputs.have_authkey == '1' }}
        uses: tailscale/github-action@v2
        with:
          authkey: ${{ secrets.TAILSCALE_AUTHKEY }}

      - name: Require Tailscale credentials
        if: ${{ steps.tscreds.outputs.have_oauth != '1' && steps.tscreds.outputs.have_authkey != '1' }}
        run: |
          echo "âŒ Missing Tailscale credentials. Configure either:\n- TS_OAUTH_CLIENT_ID and TS_OAUTH_CLIENT_SECRET (recommended)\n- or TAILSCALE_AUTHKEY (fallback)" >&2
          exit 1

      - name: Wait for Tailscale connection
        run: |
          echo "Waiting for Tailscale mesh connection..."
          timeout=30
          elapsed=0

          until tailscale status | grep -q "whitebox"; do
            if [ $elapsed -ge $timeout ]; then
              echo "âŒ Timeout waiting for Tailscale connection"
              tailscale status
              exit 1
            fi
            echo "Waiting... ($elapsed/$timeout seconds)"
            sleep 2
            elapsed=$((elapsed + 2))
          done

          echo "âœ… Tailscale connected"
          tailscale status

      - name: Health check ChatOps service
        run: |
          if ! curl -fsS --connect-timeout 10 http://whitebox.bombay-porgy.ts.net:8000/healthz; then
            echo "âŒ ChatOps service is not healthy"
            exit 1
          fi
          echo "âœ… ChatOps service is healthy"

      - name: Determine intent
        id: intent
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            INTENT="${{ github.event.inputs.intent }}"
          else
            INTENT="rollout_stack_media"
          fi
          echo "intent=$INTENT" >> $GITHUB_OUTPUT
          echo "ðŸ“‹ Will execute intent: $INTENT"

      - name: Trigger ChatOps deployment
        id: deploy
        env:
          CHATOPS_API_KEY: ${{ secrets.CHATOPS_API_KEY }}
        run: |
          INTENT="${{ steps.intent.outputs.intent }}"

          echo "ðŸš€ Triggering ChatOps: $INTENT"

          response=$(curl -X POST http://whitebox.bombay-porgy.ts.net:8000/run \
            -H "X-API-Key: $CHATOPS_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"name\": \"$INTENT\"}" \
            -w "\n%{http_code}" \
            -s -o response.json)

          http_code=$(echo "$response" | tail -n1)

          echo "ðŸ“Š HTTP Status: $http_code"

          if [ -f response.json ]; then
            echo "ðŸ“„ Response:"
            cat response.json | jq . || cat response.json
          fi

          if [ "$http_code" -ne 200 ]; then
            echo "âŒ ChatOps deployment failed with status $http_code"
            exit 1
          fi

          echo "âœ… ChatOps deployment triggered successfully"

      - name: Wait for stack stabilization
        run: |
          echo "â³ Waiting 30 seconds for containers to stabilize..."
          sleep 30

      - name: Post-deploy validation
        run: |
          echo "ðŸ” Validating deployed services..."

          # Check Plex
          if ! curl -fsS --connect-timeout 10 http://192.168.0.41:32400/web/index.html > /dev/null; then
            echo "âš ï¸  Plex web UI check failed (may need authentication)"
          else
            echo "âœ… Plex is responding"
          fi

          # Check if Docker containers are running (via SSH)
          # Note: This requires SSH key or agent forwarding
          # For now, we rely on ChatOps success and Uptime Kuma monitoring

          echo "âœ… Post-deploy validation complete"
          echo "ðŸ“Š Check Uptime Kuma for detailed health status"

      - name: Notify success
        if: success()
        run: |
          echo "ðŸŽ‰ Deployment successful!"
          echo "Stack: stack-media"
          echo "Intent: ${{ steps.intent.outputs.intent }}"
          echo "Commit: ${{ github.sha }}"
          echo "Triggered by: ${{ github.actor }}"

      - name: Notify failure
        if: failure()
        run: |
          echo "âŒ Deployment failed!"
          echo "Check logs above for details"
          echo "Rollback may be required"

  notify-discord:
    needs: [validate, deploy]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Send Discord notification
        env:
          DISCORD_DEPLOYMENT_WEBHOOK: ${{ secrets.DISCORD_DEPLOYMENT_WEBHOOK }}
        run: |
          if [ -z "$DISCORD_DEPLOYMENT_WEBHOOK" ]; then
            echo "â„¹ï¸  Discord webhook not configured, skipping notification"
            exit 0
          fi

          if [ "${{ needs.deploy.result }}" = "success" ]; then
            COLOR=3066993  # Green
            TITLE="âœ… Media Stack Deployed"
            DESC="Successfully deployed stack-media to production"
          else
            COLOR=15158332  # Red
            TITLE="âŒ Media Stack Deployment Failed"
            DESC="Deployment failed. Check GitHub Actions logs for details."
          fi

          COMMIT="\`${{ github.sha }}\`"
          BRANCH="\`${{ github.ref_name }}\`"
          ACTOR="${{ github.actor }}"
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"

          # Build payload with jq to avoid YAML parsing confusion
          jq -n \
            --arg title "$TITLE" \
            --arg desc "$DESC" \
            --arg commit "$COMMIT" \
            --arg branch "$BRANCH" \
            --arg actor "$ACTOR" \
            --arg url "$RUN_URL" \
            --argjson color "$COLOR" \
            '{
              embeds: [
                {
                  title: $title,
                  description: $desc,
                  color: $color,
                  fields: [
                    {name: "Commit", value: $commit, inline: true},
                    {name: "Branch", value: $branch, inline: true},
                    {name: "Actor", value: $actor, inline: true}
                  ],
                  url: $url
                }
              ]
            }' > payload.json

          curl -sS -X POST "$DISCORD_DEPLOYMENT_WEBHOOK" \
            -H "Content-Type: application/json" \
            --data @payload.json
